
var funcs = require("general.functions");
var register = require("general.sourceregistering")
// Comments below this are generated by chatgpt, so it may be a little inaccurate
function reverseDirectionTo(target) {
    let reverseDict = {
            3: 7,          // RIGHT → LEFT
            7: 3,          // LEFT → RIGHT
            1: 5,          // TOP → BOTTOM
            5: 1,          // BOTTOM → TOP
            8: 6,          // TOP_LEFT → BOTTOM_LEFT
            6: 8,          // BOTTOM_LEFT → TOP_LEFT
            2: 4,          // TOP_RIGHT → BOTTOM_RIGHT
            4: 2           // BOTTOM_RIGHT → TOP_RIGHT
        }
return reverseDict[creep.pos.getDirectionTo(target)]
}
var code = {
    tick: function () {
        // Check if there are any rooms that need updates in the global queue
        if (global.nextupdate.length > 0) {
            let stop = 0; // Counter to limit the number of rooms processed per tick

            // Iterate through rooms in the update queue
            for (const run in global.nextupdate) {
                try {
                stop += 1;
                if (stop > 10) { // Limit to 10 rooms per tick to avoid lag (note: this is usually 3 but increased because the harvesting becomes unbearably slow)
                    break;
                }

                // Retrieve and rotate the first room in the update queue
                let temp = global.nextupdate[0];
                global.nextupdate = funcs.Lremove(global.nextupdate, temp);
                global.nextupdate.push(temp);

                // Get room information and mining data from memory
                let RoomObject = Memory.miningrooms[temp];
                let info = Memory.longrangemining[temp];

                // Initialize mining data if it doesn't exist
                if (info == undefined) {
                    info = { creeps: [], sources: [], wantcreeps: 0 };
                    Memory.longrangemining[temp] = info;
                }
                // If no creeps are currently wanted for mining, check if there's a creep available to send
                if (Memory.longrangemining[temp].wantcreeps == 0) {
                    if (Memory.longrangemining[temp].creeps.length > 0) {
                        // Move an existing creep to the room to estimate the required miners
                        let creep = Game.creeps[Memory.longrangemining[temp].creeps[0]];
                        let roompos = new RoomPosition(25, 25, RoomObject.room);
                        creep.moveTo(roompos, { reusePath: 200, visualizePathStyle: { stroke: '#ffffff' } });

                        // Once the creep is in the target room, determine the number of mining sources
                        if (creep.room.name == RoomObject.room) {
                            Memory.longrangemining[temp].wantcreeps = creep.room.find(FIND_SOURCES).length;
                        }
                    } else {
                        // Request a new creep for the room if none are available
                        let request = this.creeprequest(Memory.longrangemining[temp]);
                        if (request !== null) {
                            Memory.longrangemining[temp].creeps.push(request);
                        }
                    }
                } else {
                    // If more creeps are needed, request additional creeps
                    if (Memory.longrangemining[temp].creeps.length < Memory.longrangemining[temp].wantcreeps) {
                        let request = this.creeprequest(Memory.longrangemining[temp]);
                        if (request !== null) {
                            Memory.longrangemining[temp].creeps.push(request);
                        }
                    }
                    // Iterate through all assigned creeps for this mining room
                    for (const nameold in Memory.longrangemining[temp].creeps) {
                        let Cname = Memory.longrangemining[temp].creeps[nameold];
                        let creep = Game.creeps[Cname];
                        // If the creep is dead, remove it from memory
                        if (creep === undefined) {
                            try {
                                let creepmem = {memory: Memory.creeps[Cname]}
                                register.remove("sources", creepmem, true, Memory.longrangemining[temp]);
                            } catch(e) {console.log("Error at line 68 of longrangeharvesting: "+e)}
                            Memory.longrangemining[temp].creeps = funcs.Lremove(Memory.longrangemining[temp].creeps, Cname);
                            continue;
                        }

                        // Display label indicating the creep's mining task and target room
                        new RoomVisual(creep.room.name).text('LRM, mining for room: ' + RoomObject.room, creep.pos.x, creep.pos.y + 1, { align: 'center', font: 0.3, color: 'blue', stroke: "white", strokeWidth: 0.01 });
                        if(creep.pos.findInRange(FIND_HOSTILE_CREEPS, 5).length > 0) {
                            let alreadyrequested = -1
                            for(let temp in Memory.defenserequests) {
                                if(Memory.defenserequests[temp].room == creep.memory.room.name) {
                                    alreadyrequested = 1
                                }
                            }
                            if(alreadyrequested == -1) {
                            Memory.defenserequests.push({x:creep.pos.x,y:creep.pos.y,room:creep.room.name})
                            }
                            global.defenseNeeded = 1
                        }
                        // If the creep's energy is not full and it should be mining
                        if (creep.memory.state !== "moving") {
                            if (creep.room.name != RoomObject.room) {
                                // Move the creep to the target room center if it’s not in the correct room
                                let roompos = new RoomPosition(25, 25, RoomObject.room);
                                creep.moveTo(roompos, { reusePath: 200, visualizePathStyle: { stroke: '#ffffff' } });
                            } else {
                                if(creep.ticksToLive > 10) {
                                    // Register creep to a source and initiate harvesting
                                    info = register.register("sources", creep, true, Memory.longrangemining[temp]);
                                    if(register.harvest(creep) == OK) {
                                        creep.memory.check=1
                                    }
                                    if(creep.store[RESOURCE_ENERGY] > 40) {
                                        creep.memory.check=1
                                        creep.drop(RESOURCE_ENERGY)
                                    }
                                } else {
                                    register.remove("sources", creep, true, Memory.longrangemining[temp]);
                                    creep.say("I die :(")
                                }
                            }
                        } else {
                            if(creep.store[RESOURCE_ENERGY] > 40) {
                                creep.drop(RESOURCE_ENERGY)
                            }
                            // Creep is full or has no energy left, determine next state (mining or moving)
                            if (creep.store[RESOURCE_ENERGY] == 0) {
                                creep.memory.state = "mining";
                            } else {
                                creep.memory.state = "moving";
                            }

                            // If creep is not in the spawn room, move it back
                            if (creep.room.name != Game.spawns["Spawn1"].room.name) {
                                creep.moveTo(Game.spawns["Spawn1"], { reusePath: 40, visualizePathStyle: { stroke: '#ffffff' } });
                                if(Math.random() > 0.5) {
                                    creep.memory.tasktype = "spawning"
                                } else {
                                    creep.memory.tasktype = "upgrading"
                                }
                            } else {
                                if(creep.memory.tasktype == undefined) {
                                    creep.memory.tasktype = "spawning"
                                }
                                if(creep.ticksToLive < 900) Game.spawns["Spawn1"].renewCreep(creep)
                                // Find structures that need energy and transfer to them
                                if(creep.memory.tasktype == "spawning") {
                                    var targets = creep.room.find(FIND_STRUCTURES, {
                                        filter: (structure) => {
                                            return (structure.structureType == STRUCTURE_EXTENSION || structure.structureType == STRUCTURE_SPAWN) &&
                                                structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
                                        }
                                    });
                                    if (targets.length > 0) {
                                        if (creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                                            creep.moveTo(targets[0], { reusePath: 40, visualizePathStyle: { stroke: '#ffffff' } });
                                        }
                                    }
                                } else {
                                    if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {
                                        creep.moveTo(creep.room.controller,{reusePath: 40,visualizePathStyle: {stroke: '#f46f02'}});
                                    }
                                }
                            }
                        }
                    }
                }
            } catch(err) {
                console.log("site "+run+" errored out with error "+err)
            }
            }
        }

        // Reset and refill the global update queue for the next tick
        global.nexttick = [];
        global.nextupdate = [];
        for (I in Memory.miningrooms) {
            if (!global.nextupdate.includes(I)) {
                global.nextupdate.push(I);
            }
        }
    },

    // Request a new creep from stored creep memory, if available
    creeprequest: function(info) {
        if (Memory.storedcreeps.length > 0) {
            let creep = Memory.storedcreeps[0];
            Memory.storedcreeps = funcs.Lremove(Memory.storedcreeps, creep);
            return creep;
        }
        return null;
    },
};

module.exports = code;