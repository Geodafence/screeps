
var funcs = require("general.functions");
var register = require("general.sourceregistering")
// Comments below this are generated by chatgpt, so it may be a little inaccurate
function reverseDirectionTo(target) {
    let reverseDict = {
        3: 7,          // RIGHT → LEFT
        7: 3,          // LEFT → RIGHT
        1: 5,          // TOP → BOTTOM
        5: 1,          // BOTTOM → TOP
        8: 6,          // TOP_LEFT → BOTTOM_LEFT
        6: 8,          // BOTTOM_LEFT → TOP_LEFT
        2: 4,          // TOP_RIGHT → BOTTOM_RIGHT
        4: 2           // BOTTOM_RIGHT → TOP_RIGHT
    }
    return reverseDict[creep.pos.getDirectionTo(target)]
}
var code = {
    tick: function () {
            for (const run in Memory.miningrooms) {
                
                try {

                    // Retrieve and rotate the first room in the update queue
                    let temp = run

                    // Get room information and mining data from memory
                    let RoomObject = Memory.miningrooms[temp];
                    let info = Memory.longrangemining[temp];

                    // Initialize mining data if it doesn't exist
                    if (info == undefined) {
                        info = { creeps: [], sources: [], wantcreeps: 0 };
                        Memory.longrangemining[temp] = info;
                    }
                    // If no creeps are currently wanted for mining, check if there's a creep available to send
                    if (Memory.longrangemining[temp].wantcreeps == 0) {
                        if (Memory.longrangemining[temp].creeps.length > 0) {
                            // Move an existing creep to the room to estimate the required miners
                            let creep = Game.creeps[Memory.longrangemining[temp].creeps[0]];
                            let roompos = new RoomPosition(25, 25, RoomObject.room);
                            creep.moveTo(roompos, { reusePath: 200, visualizePathStyle: { stroke: '#ffffff' } });

                            // Once the creep is in the target room, determine the number of mining sources
                            if (creep.room.name == RoomObject.room) {
                                Memory.longrangemining[temp].wantcreeps = creep.room.find(FIND_SOURCES).length;
                            }
                        } else {
                            // Request a new creep for the room if none are available
                            let request = this.creeprequest(Memory.longrangemining[temp]);
                            if (request !== null) {
                                Memory.longrangemining[temp].creeps.push(request);
                            }
                        }
                    } else {
                        // If more creeps are needed, request additional creeps
                        if (Memory.longrangemining[temp].creeps.length < Memory.longrangemining[temp].wantcreeps) {
                            let request = this.creeprequest(Memory.longrangemining[temp]);
                            if (request !== null) {
                                Memory.longrangemining[temp].creeps.push(request);
                            }
                        }
                        // Iterate through all assigned creeps for this mining room
                        for (const nameold in Memory.longrangemining[temp].creeps) {
                            let Cname = Memory.longrangemining[temp].creeps[nameold];
                            let creep = Game.creeps[Cname];
                            // If the creep is dead, remove it from memory
                            if (creep === undefined) {
                                try {
                                    let creepmem = { memory: Memory.creeps[Cname] }
                                    register.remove("sources", creepmem, true, Memory.longrangemining[temp]);
                                } catch (e) { console.log("Error at line 68 of longrangeharvesting: " + e) }
                                Memory.longrangemining[temp].creeps = funcs.Lremove(Memory.longrangemining[temp].creeps, Cname);
                                continue;
                            }

                            // Display label indicating the creep's mining task and target room
                            new RoomVisual(creep.room.name).text('LRM, mining for room: ' + RoomObject.room, creep.pos.x, creep.pos.y + 1, { align: 'center', font: 0.3, color: 'blue', stroke: "white", strokeWidth: 0.01 });
                            if (creep.pos.findInRange(FIND_HOSTILE_CREEPS, 5).length > 0) {
                                let alreadyrequested = -1
                                for (let temp in Memory.defenserequests) {
                                    if (Memory.defenserequests[temp].room == creep.memory.room.name) {
                                        alreadyrequested = 1
                                    }
                                }
                                if (alreadyrequested == -1) {
                                    Memory.defenserequests.push({ x: creep.pos.x, y: creep.pos.y, room: creep.room.name })
                                }
                                global.defenseNeeded = 1
                            }
                            // If the creep's energy is not full and it should be mining
                            if (creep.memory.state !== "moving") {
                                if (creep.room.name != RoomObject.room) {
                                    // Move the creep to the target room center if it’s not in the correct room
                                    let roompos = new RoomPosition(25, 25, RoomObject.room);
                                    creep.memory.CalcFrom = {x:creep.pos.x,y:creep.pos.y,room:creep.room.name}
                                    creep.moveTo(roompos, { reusePath: 200, visualizePathStyle: { stroke: '#ffffff' } });
                                } else {
                                    if (creep.ticksToLive > 10) {
                                        // Register creep to a source and initiate harvesting
                                        info = register.register("sources", creep, true, Memory.longrangemining[temp]);
                                        if (register.harvest(creep) == OK) {
                                            creep.memory.check = 1
                                        }
                                        if(Game.getObjectById(creep.memory.registeredsource)!==null&&creep.memory.CalcFrom!==undefined&&!(creep.name in Memory.LRMpaths)) {
                                            let cachePath = PathFinder.search(new RoomPosition(creep.memory.CalcFrom.x,creep.memory.CalcFrom.y,creep.memory.CalcFrom.room),new RoomPosition(creep.pos.x,creep.pos.y,creep.room.name))
                                            Memory.LRMpaths[creep.name] = cachePath
                                        } 
                                        if (creep.store[RESOURCE_ENERGY] > 40) {
                                            creep.memory.check = 1
                                            creep.drop(RESOURCE_ENERGY)
                                        }
                                    } else {
                                        register.remove("sources", creep, true, Memory.longrangemining[temp]);
                                        Memory.LRMpaths[creep.name] = undefined
                                        creep.say("I die :(")
                                    }
                                }
                            } else {
                                if (creep.store[RESOURCE_ENERGY] > 40) {
                                    creep.drop(RESOURCE_ENERGY)
                                }
                                // Creep is full or has no energy left, determine next state (mining or moving)
                                if (creep.store[RESOURCE_ENERGY] == 0) {
                                    creep.memory.state = "mining";
                                } else {
                                    creep.memory.state = "moving";
                                }
                                    /*                                 if(creep.memory.tasktype == undefined) {
                                                                        creep.memory.tasktype = "spawning"
                                                                    }
                                                                    if(creep.ticksToLive < 900) Game.spawns["Spawn1"].renewCreep(creep)
                                                                    // Find structures that need energy and transfer to them
                                                                    if(creep.memory.tasktype == "spawning") {
                                                                        var targets = creep.room.find(FIND_STRUCTURES, {
                                                                            filter: (structure) => {
                                                                                return (structure.structureType == STRUCTURE_EXTENSION || structure.structureType == STRUCTURE_SPAWN) &&
                                                                                    structure.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
                                                                            }
                                                                        });
                                                                        if (targets.length > 0) {
                                                                            if (creep.transfer(targets[0], RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                                                                                creep.moveTo(targets[0], { reusePath: 40, visualizePathStyle: { stroke: '#ffffff' } });
                                                                            }
                                                                        }
                                                                    } else {
                                                                        if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {
                                                                            creep.moveTo(creep.room.controller,{reusePath: 40,visualizePathStyle: {stroke: '#f46f02'}});
                                                                        }
                                                                    } 
                                    */
                            }
                        }
                    }
                } catch (err) {
                    console.log("site " + run + " errored out with error " + err)
                }
            }

    },

    // Request a new creep from stored creep memory, if available
    creeprequest: function (info) {
        if (Memory.storedcreeps.length > 0) {
            let creep = Memory.storedcreeps[0];
            Memory.storedcreeps = funcs.Lremove(Memory.storedcreeps, creep);
            return creep;
        }
        return null;
    },
};

module.exports = code;